{% extends "base.html" %}

{% block title %}Edit List - List Point{% endblock %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <h1 class="text-3xl font-bold mb-6">Edit List</h1>
    <form method="POST" enctype="multipart/form-data" class="card p-6 rounded-lg space-y-4">
        {{ form.hidden_tag() }}
        
        <div>
            <label class="block mb-2 font-semibold">List Name</label>
            {{ form.name(class="w-full p-2 rounded border", style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);") }}
            {% if form.name.errors %}
                <p class="text-red-500 text-sm mt-1">{{ form.name.errors[0] }}</p>
            {% endif %}
        </div>
        
        <div>
            <label class="block mb-2 font-semibold">Thumbnail Image (optional, max 500KB)</label>
            <div id="thumbnail-preview-container" class="mb-2">
                {% if current_list.thumbnail_url %}
                    <img id="thumbnail-preview" src="{{ current_list.thumbnail_url }}" alt="Current thumbnail" class="h-40 object-cover rounded">
                {% else %}
                    <img id="thumbnail-preview" src="" alt="Preview" class="h-40 object-cover rounded hidden">
                {% endif %}
            </div>
            <input type="file" id="thumbnail-input" name="thumbnail" accept="image/*" class="hidden">
            <button type="button" onclick="document.getElementById('thumbnail-input').click()" class="px-4 py-2 rounded border hover:opacity-70" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                Choose File
            </button>
            <span id="file-name" class="ml-2" style="color: var(--text-secondary);"></span>
        </div>
        
        <div>
            <label class="block mb-2 font-semibold">Tags (comma-separated)</label>
            {{ form.tags(class="w-full p-2 rounded border", style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);") }}
        </div>
        
        <div class="flex items-center space-x-6">
            <label class="flex items-center space-x-2">
                {{ form.is_public(class="w-4 h-4") }}
                <span>Make Public</span>
            </label>
            
            {% if current_list.is_ethereal %}
                <span class="text-sm" style="color: var(--text-secondary);">âœ¨ Check List</span>
            {% endif %}
        </div>
        
        <div class="border-t pt-4" style="border-color: var(--border-color);">
            <h3 class="font-semibold mb-3">Collaborators</h3>
            <p class="text-sm mb-3" style="color: var(--text-secondary);">
                Invite users to help manage this list. Collaborators can add items and view private lists.
            </p>
            
            <div class="flex space-x-2 mb-2">
                <input 
                    type="text" 
                    id="collaborator-search" 
                    placeholder="Search usernames" 
                    class="flex-1 p-2 rounded border" 
                    style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);"
                >
                <button 
                    type="button" 
                    onclick="searchUsers()" 
                    class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                    Search
                </button>
            </div>
            
            <div id="collaborator-message" class="mb-2 text-sm hidden"></div>
            
            <div id="search-results" class="mb-3 space-y-1"></div>
            
            <div id="collaborators-list" class="space-y-2">
                {% if collaborators %}
                    {% for collaborator in collaborators %}
                        <div id="collab-{{ collaborator._id }}" class="flex items-center justify-between p-2 rounded" style="background-color: var(--bg-primary);">
                            <span>{{ collaborator.username }}</span>
                            <button 
                                type="button" 
                                onclick="removeCollaborator('{{ collaborator._id }}')" 
                                class="text-red-500 hover:text-red-700"
                            >
                                Remove
                            </button>
                        </div>
                    {% endfor %}
                {% else %}
                    <p class="text-sm" style="color: var(--text-secondary);">No collaborators yet</p>
                {% endif %}
            </div>
        </div>
        
        <div class="flex space-x-4">
            <button type="submit" class="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700">
                Save Changes
            </button>
            <a href="{{ url_for('view_list', list_id=current_list._id) }}" class="flex-1 card py-2 rounded text-center hover:opacity-80">
                Cancel
            </a>
        </div>
    </form>
</div>

<!-- Image Crop Modal -->
<div id="crop-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50" style="z-index: 9999;">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-4xl w-full mx-4" style="background-color: var(--bg-secondary);">
        <h3 class="text-xl font-bold mb-4">Crop Your Thumbnail</h3>
        
        <div class="relative inline-block mb-4">
            <canvas id="crop-canvas" class="max-w-full border" style="border-color: var(--border-color); max-height: 70vh; cursor: move;"></canvas>
        </div>
        
        <div class="flex justify-end space-x-3">
            <button type="button" onclick="cancelCrop()" class="px-4 py-2 rounded border hover:opacity-70" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                Cancel
            </button>
            <button type="button" onclick="applyCrop()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                Apply Crop
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const listId = '{{ current_list._id|string }}';
    
    let searchTimeout;
    const searchInput = document.getElementById('collaborator-search');
    const existingCollaborators = new Set();
    
    // Track existing collaborators
    document.querySelectorAll('#collaborators-list [id^="collab-"]').forEach(el => {
        const username = el.querySelector('span').textContent.trim();
        existingCollaborators.add(username.toLowerCase());
    });
    
    searchInput.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            if (searchInput.value.trim().length >= 2) {
                searchUsers();
            } else {
                document.getElementById('search-results').innerHTML = '';
            }
        }, 300);
    });
    
    searchInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            searchUsers();
        }
    });
    
    function showMessage(text, isSuccess = true) {
        const msgDiv = document.getElementById('collaborator-message');
        msgDiv.textContent = text;
        msgDiv.className = `mb-2 text-sm ${isSuccess ? 'text-green-500' : 'text-red-500'}`;
        msgDiv.classList.remove('hidden');
        
        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            msgDiv.classList.add('hidden');
        }, 3000);
    }
    
    async function searchUsers() {
        const query = searchInput.value.trim();
        const resultsDiv = document.getElementById('search-results');
        
        if (query.length < 2) {
            resultsDiv.innerHTML = '<p class="text-sm" style="color: var(--text-secondary);">Type at least 2 characters</p>';
            return;
        }
        
        resultsDiv.innerHTML = '<p class="text-sm" style="color: var(--text-secondary);">Searching...</p>';
        
        try {
            const response = await fetch(`/api/search_users?q=${encodeURIComponent(query)}`);
            const data = await response.json();
            
            if (data.users && data.users.length > 0) {
                // Filter out existing collaborators
                const availableUsers = data.users.filter(user => 
                    !existingCollaborators.has(user.username.toLowerCase())
                );
                
                if (availableUsers.length > 0) {
                    resultsDiv.innerHTML = availableUsers.map(user => `
                        <div class="flex items-center justify-between p-2 rounded hover:opacity-80" style="background-color: var(--bg-primary);">
                            <span>${user.username}</span>
                            <button 
                                type="button" 
                                onclick="addCollaborator('${user.username}')" 
                                class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                            >
                                Add
                            </button>
                        </div>
                    `).join('');
                } else {
                    resultsDiv.innerHTML = '<p class="text-sm" style="color: var(--text-secondary);">All matching users are already collaborators</p>';
                }
            } else {
                resultsDiv.innerHTML = '<p class="text-sm" style="color: var(--text-secondary);">No users found</p>';
            }
        } catch (error) {
            resultsDiv.innerHTML = '<p class="text-sm text-red-500">Error searching users</p>';
        }
    }
    
    async function addCollaborator(username) {
        try {
            const response = await fetch(`/api/lists/${listId}/collaborators`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ username })
            });
            
            if (!response.ok) {
                const data = await response.json();
                showMessage(data.message || 'Failed to add collaborator', false);
                return;
            }
            
            const data = await response.json();
            
            if (data.success) {
                const collaboratorsList = document.getElementById('collaborators-list');
                const userId = data.user._id;
                
                // Remove "no collaborators" message if it exists
                const noCollabMsg = collaboratorsList.querySelector('p');
                if (noCollabMsg) noCollabMsg.remove();
                
                // Add new collaborator to list
                const collabDiv = document.createElement('div');
                collabDiv.id = `collab-${userId}`;
                collabDiv.className = 'flex items-center justify-between p-2 rounded';
                collabDiv.style.backgroundColor = 'var(--bg-primary)';
                collabDiv.innerHTML = `
                    <span>${username}</span>
                    <button 
                        type="button" 
                        onclick="removeCollaborator('${userId}')" 
                        class="text-red-500 hover:text-red-700"
                    >
                        Remove
                    </button>
                `;
                collaboratorsList.appendChild(collabDiv);
                
                // Add to existing collaborators set
                existingCollaborators.add(username.toLowerCase());
                
                // Clear search results and show success message
                document.getElementById('search-results').innerHTML = '';
                showMessage('Collaborator added successfully!');
                
                // Keep input focused
                searchInput.focus();
            } else {
                showMessage(data.message || 'Failed to add collaborator', false);
            }
        } catch (error) {
            console.error('Error adding collaborator:', error);
            showMessage('Error adding collaborator: ' + error.message, false);
        }
    }
    
    async function removeCollaborator(userId) {
        if (!confirm('Remove this collaborator?')) return;
        
        try {
            // Get username before removing
            const collabElement = document.getElementById(`collab-${userId}`);
            const username = collabElement.querySelector('span').textContent.trim();
            
            const response = await fetch(`/api/lists/${listId}/collaborators/${userId}`, {
                method: 'DELETE'
            });
            
            const data = await response.json();
            
            if (data.success) {
                collabElement.remove();
                
                // Remove from existing collaborators set
                existingCollaborators.delete(username.toLowerCase());
                
                const collaboratorsList = document.getElementById('collaborators-list');
                if (collaboratorsList.children.length === 0) {
                    collaboratorsList.innerHTML = '<p class="text-sm" style="color: var(--text-secondary);">No collaborators yet</p>';
                }
                
                showMessage('Collaborator removed successfully!');
            } else {
                showMessage(data.message || 'Failed to remove collaborator', false);
            }
        } catch (error) {
            showMessage('Error removing collaborator', false);
        }
    }
    
    const thumbnailInput = document.getElementById('thumbnail-input');
    const fileNameSpan = document.getElementById('file-name');
    const maxSize = 500 * 1024; // 500KB in bytes
    
    let currentImage = null;
    let cropArea = { x: 0, y: 0, width: 0, height: 0 };
    let isDragging = false;
    let isResizing = false;
    let dragStart = { x: 0, y: 0 };
    let resizeHandle = null;
    let resizeAnchor = { x: 0, y: 0 };
    let canvas, ctx;
    let displayScale = 1;

    function showCropModal(img) {
        currentImage = img;
        const modal = document.getElementById('crop-modal');
        canvas = document.getElementById('crop-canvas');
        ctx = canvas.getContext('2d');
        
        // Calculate display size while maintaining aspect ratio
        const maxWidth = window.innerWidth * 0.8;
        const maxHeight = window.innerHeight * 0.7;
        let displayWidth = img.width;
        let displayHeight = img.height;
        
        if (displayWidth > maxWidth || displayHeight > maxHeight) {
            const widthRatio = maxWidth / displayWidth;
            const heightRatio = maxHeight / displayHeight;
            displayScale = Math.min(widthRatio, heightRatio);
            displayWidth = img.width * displayScale;
            displayHeight = img.height * displayScale;
        } else {
            displayScale = 1;
        }
        
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        
        // Initialize crop area (centered, reasonable size)
        const cropWidth = Math.min(displayWidth * 0.7, displayHeight);
        const cropHeight = cropWidth * (160 / 300); // Aspect ratio of thumbnails
        cropArea = {
            x: (displayWidth - cropWidth) / 2,
            y: (displayHeight - cropHeight) / 2,
            width: cropWidth,
            height: cropHeight
        };
        
        setupCanvasEvents();
        drawCropInterface();
        
        // Lock body scroll
        document.body.style.overflow = 'hidden';
        
        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    function drawCropInterface() {
        // Draw the full image
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
        
        // Draw darkened overlay outside crop area
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Clear the crop area (shows image normally)
        ctx.clearRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        ctx.drawImage(currentImage, 
            cropArea.x / displayScale, cropArea.y / displayScale, 
            cropArea.width / displayScale, cropArea.height / displayScale,
            cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        
        // Draw crop rectangle border (thicker for mobile)
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.strokeRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        
        // Draw resize handles (larger for mobile)
        const handleSize = 20;
        ctx.fillStyle = '#3b82f6';
        // Corners
        ctx.fillRect(cropArea.x - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
    }
    
    function getResizeHandle(x, y) {
        const handleSize = 20;
        const handles = [
            { name: 'nw', x: cropArea.x, y: cropArea.y },
            { name: 'ne', x: cropArea.x + cropArea.width, y: cropArea.y },
            { name: 'sw', x: cropArea.x, y: cropArea.y + cropArea.height },
            { name: 'se', x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height }
        ];
        
        for (let handle of handles) {
            if (Math.abs(x - handle.x) <= handleSize && Math.abs(y - handle.y) <= handleSize) {
                return handle.name;
            }
        }
        return null;
    }


    function setupCanvasEvents() {
        // Handle start of drag (mouse or touch)
        function handleStart(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            // Check if clicking/touching a resize handle
            resizeHandle = getResizeHandle(x, y);
            if (resizeHandle) {
                isResizing = true;
                dragStart = { x, y };
                
                // Set anchor point (opposite corner from handle)
                if (resizeHandle === 'se') {
                    resizeAnchor = { x: cropArea.x, y: cropArea.y };
                } else if (resizeHandle === 'sw') {
                    resizeAnchor = { x: cropArea.x + cropArea.width, y: cropArea.y };
                } else if (resizeHandle === 'ne') {
                    resizeAnchor = { x: cropArea.x, y: cropArea.y + cropArea.height };
                } else if (resizeHandle === 'nw') {
                    resizeAnchor = { x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height };
                }
            }
            // Check if touch/click is inside crop area for dragging
            else if (x >= cropArea.x && x <= cropArea.x + cropArea.width &&
                     y >= cropArea.y && y <= cropArea.y + cropArea.height) {
                isDragging = true;
                dragStart = { x, y };
            }
        }
        
        // Handle drag movement (mouse or touch)
        function handleMove(e) {
            if (!isDragging && !isResizing) return;
            
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            if (isResizing && resizeHandle) {
                const aspectRatio = 160 / 300;
                
                if (resizeHandle === 'se') {
                    const newWidth = Math.max(50, x - resizeAnchor.x);
                    const newHeight = newWidth * aspectRatio;
                    cropArea.x = resizeAnchor.x;
                    cropArea.y = resizeAnchor.y;
                    cropArea.width = newWidth;
                    cropArea.height = newHeight;
                } else if (resizeHandle === 'sw') {
                    const newWidth = Math.max(50, resizeAnchor.x - x);
                    const newHeight = newWidth * aspectRatio;
                    cropArea.x = resizeAnchor.x - newWidth;
                    cropArea.y = resizeAnchor.y;
                    cropArea.width = newWidth;
                    cropArea.height = newHeight;
                } else if (resizeHandle === 'ne') {
                    const newWidth = Math.max(50, x - resizeAnchor.x);
                    const newHeight = newWidth * aspectRatio;
                    cropArea.x = resizeAnchor.x;
                    cropArea.y = resizeAnchor.y - newHeight;
                    cropArea.width = newWidth;
                    cropArea.height = newHeight;
                } else if (resizeHandle === 'nw') {
                    const newWidth = Math.max(50, resizeAnchor.x - x);
                    const newHeight = newWidth * aspectRatio;
                    cropArea.x = resizeAnchor.x - newWidth;
                    cropArea.y = resizeAnchor.y - newHeight;
                    cropArea.width = newWidth;
                    cropArea.height = newHeight;
                }
                
                // Keep within bounds
                cropArea.x = Math.max(0, cropArea.x);
                cropArea.y = Math.max(0, cropArea.y);
                cropArea.width = Math.min(cropArea.width, canvas.width - cropArea.x);
                cropArea.height = Math.min(cropArea.height, canvas.height - cropArea.y);
                
                drawCropInterface();
            } else if (isDragging) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                
                cropArea.x = Math.max(0, Math.min(canvas.width - cropArea.width, cropArea.x + dx));
                cropArea.y = Math.max(0, Math.min(canvas.height - cropArea.height, cropArea.y + dy));
                
                dragStart = { x, y };
                drawCropInterface();
            }
        }
        
        // Handle end of drag (mouse or touch)
        function handleEnd(e) {
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd);
    }
    
    function cleanupCanvasEvents() {
        // Note: we can't remove the event listeners because they're defined inside setupCanvasEvents
        // This is okay - they only run when isDragging is true, which we reset
        isDragging = false;
        isResizing = false;
    }

    function cancelCrop() {
        cleanupCanvasEvents();
        
        const modal = document.getElementById('crop-modal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // Unlock body scroll
        document.body.style.overflow = '';
        
        thumbnailInput.value = '';
        fileNameSpan.textContent = 'No file chosen';
        fileNameSpan.style.color = 'var(--text-secondary)';
    }

    async function applyCrop() {
        cleanupCanvasEvents();
        
        const modal = document.getElementById('crop-modal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // Unlock body scroll
        document.body.style.overflow = '';
        
        fileNameSpan.textContent = 'Processing image...';
        fileNameSpan.style.color = '#fbbf24';
        
        // Create a new canvas for the cropped image
        const cropCanvas = document.createElement('canvas');
        const cropCtx = cropCanvas.getContext('2d');
        
        // Set canvas to actual crop size
        const actualX = cropArea.x / displayScale;
        const actualY = cropArea.y / displayScale;
        const actualWidth = cropArea.width / displayScale;
        const actualHeight = cropArea.height / displayScale;
        
        cropCanvas.width = actualWidth;
        cropCanvas.height = actualHeight;
        
        // Draw the cropped portion
        cropCtx.drawImage(currentImage, actualX, actualY, actualWidth, actualHeight, 0, 0, actualWidth, actualHeight);
        
        // Convert to blob and compress if needed
        cropCanvas.toBlob(async (blob) => {
            let finalBlob = blob;
            
            // Compress if over size limit
            if (blob.size > maxSize) {
                finalBlob = await compressBlob(cropCanvas, actualWidth, actualHeight);
            }
            
            const file = new File([finalBlob], 'thumbnail.jpg', {
                type: 'image/jpeg',
                lastModified: Date.now()
            });
            
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            thumbnailInput.files = dataTransfer.files;
            
            // Show preview of cropped image
            const previewUrl = URL.createObjectURL(file);
            const previewImg = document.getElementById('thumbnail-preview');
            previewImg.src = previewUrl;
            previewImg.classList.remove('hidden');
            
            fileNameSpan.textContent = `Cropped image (${(file.size / 1024).toFixed(0)}KB)`;
            fileNameSpan.style.color = '#10b981';
        }, 'image/jpeg', 0.9);
    }

    async function compressBlob(canvas, width, height) {
        return new Promise((resolve) => {
            let quality = 0.8;
            let currentWidth = width;
            let currentHeight = height;
            
            function tryCompress() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentWidth;
                tempCanvas.height = currentHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0, width, height, 0, 0, currentWidth, currentHeight);
                
                tempCanvas.toBlob((blob) => {
                    if (blob.size <= maxSize || quality <= 0.1) {
                        resolve(blob);
                    } else {
                        if (quality > 0.5) {
                            quality -= 0.1;
                        } else {
                            currentWidth = Math.floor(currentWidth * 0.9);
                            currentHeight = Math.floor(currentHeight * 0.9);
                            quality = 0.8;
                        }
                        tryCompress();
                    }
                }, 'image/jpeg', quality);
            }
            
            tryCompress();
        });
    }

    async function compressImage(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    let width = img.width;
                    let height = img.height;
                    let quality = 0.9;
                    
                    // Start with reasonable max dimensions
                    const maxDimension = 1200;
                    if (width > maxDimension || height > maxDimension) {
                        if (width > height) {
                            height = (height / width) * maxDimension;
                            width = maxDimension;
                        } else {
                            width = (width / height) * maxDimension;
                            height = maxDimension;
                        }
                    }
                    
                    function tryCompress() {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob((blob) => {
                            if (blob.size <= maxSize || quality <= 0.1) {
                                // Success or can't compress more
                                const compressedFile = new File([blob], file.name, {
                                    type: 'image/jpeg',
                                    lastModified: Date.now()
                                });
                                resolve(compressedFile);
                            } else {
                                // Try reducing quality or dimensions
                                if (quality > 0.5) {
                                    quality -= 0.1;
                                } else {
                                    width = Math.floor(width * 0.9);
                                    height = Math.floor(height * 0.9);
                                    quality = 0.8;
                                }
                                tryCompress();
                            }
                        }, 'image/jpeg', quality);
                    }
                    
                    tryCompress();
                };
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        });
    }

    thumbnailInput.addEventListener('change', async function(e) {
        const file = e.target.files[0];
        
        if (!file) {
            fileNameSpan.textContent = 'No file chosen';
            fileNameSpan.style.color = 'var(--text-secondary)';
            return;
        }

        // Check if it's an image
        if (!file.type.startsWith('image/')) {
            fileNameSpan.textContent = 'Please select an image file';
            fileNameSpan.style.color = '#ef4444';
            thumbnailInput.value = '';
            return;
        }

        // Show loading message
        fileNameSpan.textContent = 'Loading image...';
        fileNameSpan.style.color = '#fbbf24';
        
        // Load image and show crop modal
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                showCropModal(img);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
</script>
{% endblock %}
