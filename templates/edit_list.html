{% extends "base.html" %}

{% block title %}Edit List - List Tracker{% endblock %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <h1 class="text-3xl font-bold mb-6">Edit List</h1>
    <form method="POST" enctype="multipart/form-data" class="card p-6 rounded-lg space-y-4">
        {{ form.hidden_tag() }}
        
        <div>
            <label class="block mb-2 font-semibold">List Name</label>
            {{ form.name(class="w-full p-2 rounded border", style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);") }}
            {% if form.name.errors %}
                <p class="text-red-500 text-sm mt-1">{{ form.name.errors[0] }}</p>
            {% endif %}
        </div>
        
        <div>
            <label class="block mb-2 font-semibold">Thumbnail Image (optional, max 500KB)</label>
            {% if current_list.thumbnail_url %}
                <img src="{{ current_list.thumbnail_url }}" alt="Current thumbnail" class="w-32 h-32 object-cover rounded mb-2">
            {% endif %}
            <input type="file" id="thumbnail-input" name="thumbnail" accept="image/*" class="hidden">
            <button type="button" onclick="document.getElementById('thumbnail-input').click()" class="px-4 py-2 rounded border hover:opacity-70" style="background-color: var(--bg-secondary); border-color: var(--border-color); color: var(--text-primary);">
                Choose File
            </button>
            <span id="file-name" class="ml-2" style="color: var(--text-secondary);"></span>
        </div>
        
        <div>
            <label class="block mb-2 font-semibold">Tags (comma-separated)</label>
            {{ form.tags(class="w-full p-2 rounded border", style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);") }}
        </div>
        
        <div class="flex items-center space-x-6">
            <label class="flex items-center space-x-2">
                {{ form.is_public(class="w-4 h-4") }}
                <span>Make Public</span>
            </label>
            
            {% if current_list.is_ethereal %}
                <span class="text-sm" style="color: var(--text-secondary);">âœ¨ Ethereal List</span>
            {% endif %}
        </div>
        
        <div class="flex space-x-4">
            <button type="submit" class="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700">
                Save Changes
            </button>
            <a href="{{ url_for('view_list', list_id=current_list._id) }}" class="flex-1 card py-2 rounded text-center hover:opacity-80">
                Cancel
            </a>
        </div>
    </form>
</div>

<!-- Image Crop Modal -->
<div id="crop-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50" style="z-index: 9999;">
    <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-4xl w-full mx-4" style="background-color: var(--bg-secondary);">
        <h3 class="text-xl font-bold mb-4">Crop Your Thumbnail</h3>
        
        <div class="relative inline-block mb-4">
            <canvas id="crop-canvas" class="max-w-full border" style="border-color: var(--border-color); max-height: 70vh; cursor: move;"></canvas>
        </div>
        
        <div class="flex justify-end space-x-3">
            <button type="button" onclick="cancelCrop()" class="px-4 py-2 rounded border hover:opacity-70" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                Cancel
            </button>
            <button type="button" onclick="applyCrop()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                Apply Crop
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const thumbnailInput = document.getElementById('thumbnail-input');
    const fileNameSpan = document.getElementById('file-name');
    const maxSize = 500 * 1024; // 500KB in bytes
    
    let currentImage = null;
    let cropArea = { x: 0, y: 0, width: 0, height: 0 };
    let isDragging = false;
    let isResizing = false;
    let dragStart = { x: 0, y: 0 };
    let resizeHandle = null;
    let canvas, ctx;
    let displayScale = 1;

    function showCropModal(img) {
        currentImage = img;
        const modal = document.getElementById('crop-modal');
        canvas = document.getElementById('crop-canvas');
        ctx = canvas.getContext('2d');
        
        // Calculate display size while maintaining aspect ratio
        const maxWidth = window.innerWidth * 0.8;
        const maxHeight = window.innerHeight * 0.7;
        let displayWidth = img.width;
        let displayHeight = img.height;
        
        if (displayWidth > maxWidth || displayHeight > maxHeight) {
            const widthRatio = maxWidth / displayWidth;
            const heightRatio = maxHeight / displayHeight;
            displayScale = Math.min(widthRatio, heightRatio);
            displayWidth = img.width * displayScale;
            displayHeight = img.height * displayScale;
        } else {
            displayScale = 1;
        }
        
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        
        // Initialize crop area (centered, reasonable size)
        const cropWidth = Math.min(displayWidth * 0.7, displayHeight);
        const cropHeight = cropWidth * (160 / 300); // Aspect ratio of thumbnails
        cropArea = {
            x: (displayWidth - cropWidth) / 2,
            y: (displayHeight - cropHeight) / 2,
            width: cropWidth,
            height: cropHeight
        };
        
        setupCanvasEvents();
        drawCropInterface();
        
        // Lock body scroll
        document.body.style.overflow = 'hidden';
        
        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    function drawCropInterface() {
        // Draw the full image
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
        
        // Draw darkened overlay outside crop area
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Clear the crop area (shows image normally)
        ctx.clearRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        ctx.drawImage(currentImage, 
            cropArea.x / displayScale, cropArea.y / displayScale, 
            cropArea.width / displayScale, cropArea.height / displayScale,
            cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        
        // Draw crop rectangle border
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.strokeRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
        
        // Draw resize handles
        const handleSize = 10;
        ctx.fillStyle = '#3b82f6';
        // Corners
        ctx.fillRect(cropArea.x - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
        ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
    }

    function getResizeHandle(x, y) {
        const handleSize = 10;
        const handles = [
            { name: 'nw', x: cropArea.x, y: cropArea.y },
            { name: 'ne', x: cropArea.x + cropArea.width, y: cropArea.y },
            { name: 'sw', x: cropArea.x, y: cropArea.y + cropArea.height },
            { name: 'se', x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height }
        ];
        
        for (let handle of handles) {
            if (Math.abs(x - handle.x) <= handleSize && Math.abs(y - handle.y) <= handleSize) {
                return handle.name;
            }
        }
        return null;
    }

    function setupCanvasEvents() {
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            console.log('Mousedown at', x, y, 'cropArea:', cropArea);
            
            resizeHandle = getResizeHandle(x, y);
            if (resizeHandle) {
                isResizing = true;
                console.log('Resizing handle:', resizeHandle);
            } else if (x >= cropArea.x && x <= cropArea.x + cropArea.width &&
                       y >= cropArea.y && y <= cropArea.y + cropArea.height) {
                isDragging = true;
                console.log('Dragging started');
            }
            
            dragStart = { x, y };
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isResizing && resizeHandle) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                const aspectRatio = 160 / 300;
                
                if (resizeHandle === 'se') {
                    cropArea.width = Math.max(50, cropArea.width + dx);
                    cropArea.height = cropArea.width * aspectRatio;
                } else if (resizeHandle === 'sw') {
                    const newWidth = Math.max(50, cropArea.width - dx);
                    cropArea.x += cropArea.width - newWidth;
                    cropArea.width = newWidth;
                    cropArea.height = cropArea.width * aspectRatio;
                } else if (resizeHandle === 'ne') {
                    cropArea.width = Math.max(50, cropArea.width + dx);
                    cropArea.height = cropArea.width * aspectRatio;
                    const newY = cropArea.y + dy;
                    cropArea.y = newY;
                } else if (resizeHandle === 'nw') {
                    const newWidth = Math.max(50, cropArea.width - dx);
                    cropArea.x += cropArea.width - newWidth;
                    cropArea.width = newWidth;
                    cropArea.height = cropArea.width * aspectRatio;
                    cropArea.y += dy;
                }
                
                // Keep within bounds
                cropArea.x = Math.max(0, Math.min(cropArea.x, canvas.width - cropArea.width));
                cropArea.y = Math.max(0, Math.min(cropArea.y, canvas.height - cropArea.height));
                
                dragStart = { x, y };
                drawCropInterface();
            } else if (isDragging) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                
                console.log('Dragging: dx=', dx, 'dy=', dy);
                
                cropArea.x = Math.max(0, Math.min(canvas.width - cropArea.width, cropArea.x + dx));
                cropArea.y = Math.max(0, Math.min(canvas.height - cropArea.height, cropArea.y + dy));
                
                dragStart = { x, y };
                drawCropInterface();
            } else {
                // Update cursor based on position
                const handle = getResizeHandle(x, y);
                if (handle) {
                    canvas.style.cursor = handle.includes('n') ? 
                        (handle.includes('w') ? 'nw-resize' : 'ne-resize') :
                        (handle.includes('w') ? 'sw-resize' : 'se-resize');
                } else if (x >= cropArea.x && x <= cropArea.x + cropArea.width &&
                           y >= cropArea.y && y <= cropArea.y + cropArea.height) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
        });
    }

    function cancelCrop() {
        const modal = document.getElementById('crop-modal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // Unlock body scroll
        document.body.style.overflow = '';
        
        thumbnailInput.value = '';
        fileNameSpan.textContent = 'No file chosen';
        fileNameSpan.style.color = 'var(--text-secondary)';
    }

    async function applyCrop() {
        const modal = document.getElementById('crop-modal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // Unlock body scroll
        document.body.style.overflow = '';
        
        fileNameSpan.textContent = 'Processing image...';
        fileNameSpan.style.color = '#fbbf24';
        
        // Create a new canvas for the cropped image
        const cropCanvas = document.createElement('canvas');
        const cropCtx = cropCanvas.getContext('2d');
        
        // Set canvas to actual crop size
        const actualX = cropArea.x / displayScale;
        const actualY = cropArea.y / displayScale;
        const actualWidth = cropArea.width / displayScale;
        const actualHeight = cropArea.height / displayScale;
        
        cropCanvas.width = actualWidth;
        cropCanvas.height = actualHeight;
        
        // Draw the cropped portion
        cropCtx.drawImage(currentImage, actualX, actualY, actualWidth, actualHeight, 0, 0, actualWidth, actualHeight);
        
        // Convert to blob and compress if needed
        cropCanvas.toBlob(async (blob) => {
            let finalBlob = blob;
            
            // Compress if over size limit
            if (blob.size > maxSize) {
                finalBlob = await compressBlob(cropCanvas, actualWidth, actualHeight);
            }
            
            const file = new File([finalBlob], 'thumbnail.jpg', {
                type: 'image/jpeg',
                lastModified: Date.now()
            });
            
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            thumbnailInput.files = dataTransfer.files;
            
            fileNameSpan.textContent = `Cropped image (${(file.size / 1024).toFixed(0)}KB)`;
            fileNameSpan.style.color = '#10b981';
        }, 'image/jpeg', 0.9);
    }

    async function compressBlob(canvas, width, height) {
        return new Promise((resolve) => {
            let quality = 0.8;
            let currentWidth = width;
            let currentHeight = height;
            
            function tryCompress() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentWidth;
                tempCanvas.height = currentHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0, width, height, 0, 0, currentWidth, currentHeight);
                
                tempCanvas.toBlob((blob) => {
                    if (blob.size <= maxSize || quality <= 0.1) {
                        resolve(blob);
                    } else {
                        if (quality > 0.5) {
                            quality -= 0.1;
                        } else {
                            currentWidth = Math.floor(currentWidth * 0.9);
                            currentHeight = Math.floor(currentHeight * 0.9);
                            quality = 0.8;
                        }
                        tryCompress();
                    }
                }, 'image/jpeg', quality);
            }
            
            tryCompress();
        });
    }

    async function compressImage(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    let width = img.width;
                    let height = img.height;
                    let quality = 0.9;
                    
                    // Start with reasonable max dimensions
                    const maxDimension = 1200;
                    if (width > maxDimension || height > maxDimension) {
                        if (width > height) {
                            height = (height / width) * maxDimension;
                            width = maxDimension;
                        } else {
                            width = (width / height) * maxDimension;
                            height = maxDimension;
                        }
                    }
                    
                    function tryCompress() {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob((blob) => {
                            if (blob.size <= maxSize || quality <= 0.1) {
                                // Success or can't compress more
                                const compressedFile = new File([blob], file.name, {
                                    type: 'image/jpeg',
                                    lastModified: Date.now()
                                });
                                resolve(compressedFile);
                            } else {
                                // Try reducing quality or dimensions
                                if (quality > 0.5) {
                                    quality -= 0.1;
                                } else {
                                    width = Math.floor(width * 0.9);
                                    height = Math.floor(height * 0.9);
                                    quality = 0.8;
                                }
                                tryCompress();
                            }
                        }, 'image/jpeg', quality);
                    }
                    
                    tryCompress();
                };
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        });
    }

    thumbnailInput.addEventListener('change', async function(e) {
        const file = e.target.files[0];
        
        if (!file) {
            fileNameSpan.textContent = 'No file chosen';
            fileNameSpan.style.color = 'var(--text-secondary)';
            return;
        }

        // Check if it's an image
        if (!file.type.startsWith('image/')) {
            fileNameSpan.textContent = 'Please select an image file';
            fileNameSpan.style.color = '#ef4444';
            thumbnailInput.value = '';
            return;
        }

        // Show loading message
        fileNameSpan.textContent = 'Loading image...';
        fileNameSpan.style.color = '#fbbf24';
        
        // Load image and show crop modal
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
                showCropModal(img);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
</script>
{% endblock %}
